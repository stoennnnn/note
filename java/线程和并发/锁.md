### 2.互斥锁

#### **2.1 互斥性**

​	即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块进行访问。互斥性也称为操作的原子性

#### **2.2 可见性**

必须确保在锁被释放之前，对共享变量做出的修改，对于随后获得该锁的另一个线程时可见的，即在获得锁时应获得最新共享变量的值，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致

#### **2.3 获取对象锁**

![获取锁对象](image/5.png)

#### 2.4 对象锁和类锁总结

​	1.有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块

​	2.若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞

​	3.若锁住的时同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法线程会被阻塞

​	4.若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然

​	5.同一个类的不同对象的对象锁互不干扰

​	6.类锁由于也是一种特殊的锁，表现和上述1234一致

​	7.类锁和对象锁互不干扰

### 3.synchronized锁的实现原理

参考文章 http://www.cnblogs.com/xdyixia/p/9364247.html

#### **3.1 对象头结构**

##### 3.1.1**Mark word**

![](image/6.png)

##### 3.1.2 **Monitor**

​	可以理解为一个同步工具，也可以理解为一种同步机制，通常描述为一把锁。每个java对象都自带monitor锁。

​	Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

结构如下:

![monitor结构](image/7.png)

Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL。

EntryQ：关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。

RcThis：表示blocked或waiting在该monitor record上的所有线程的个数。

Nest：用来实现重入锁的计数。HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。

Candidate：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁　　

**Monitor锁的竞争，获取与释放，monitor对象存在于每个java对象的对象头中**

![](image/8.png)

##### **3.1.3 重入**

从互斥锁的设计来说：当一个线程试图操作一个由其它线程持有的对象锁临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有的锁的临界资源时，这种情况属于重入。

**查看同步代码块和同步方法的字节码**

##### **3.1.4 synchronized效率的提升**

**在1.6之前**

synchronizd属于重量级锁，依赖于Mutex Lock(互斥锁)实现

线程之间的切换需要从用户态切换到核心态（java操作线程需要操作系统来帮忙，即从用户态切换到核心态），开销较大

1.6后，优化了很多锁 ,自旋锁和自适应锁

###### 3.1.4.1 **自旋锁**

​	许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得；通过让线程执行忙循环等待锁的释放，不会让出CPU

​	缺点：若锁被其它线程长时间占用，会带来许多性能开销。如果自旋次数超过了限定的尝试次数，还没有成功获取到锁，就应该使用传统的方式挂起线程。使用PreBlockSpin来更改

######   **3.1.4.2 自适应自旋锁**

​	自旋的次数不固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。jvm对自旋的次数预测更加准确。

###### **3.1.4.3锁消除**

​	JIT编译时，对上下文进行扫描，去除不可能存在竞争的锁。减少毫无意义的锁时间。

###### **3.1.4.4 锁粗化**

​	比如锁操作发生在循环中。就把锁加到循环外

#### 3.2 synchronized代码块的实现原理

#### 3.3 synchronized方法的实现原理

#### 3.4 synchronized的四种状态

##### 3.4.1 锁膨胀的方向

无锁->偏向锁->轻量级锁->重量级锁

###### 3.4.1.1  **偏向锁**

减少同一线程获取锁的代价

很多时候访问一个代码块都是同一个线程

当一个线程访问同步块并获取锁时，对象头和栈帧中的锁记录里，存储锁偏向的线程id，以后该线程再进行锁进入和退出不需要进行cas操作来加锁和解锁，提高了程序性能。即：如果一个线程获得了锁，那么锁就进入偏向模式。此时mark word结构也变为偏向锁结构，当线程再次请求锁的时候，无需在做任何同步操作，即获取锁只需要检查Mark word的锁标记位为偏向锁以及当前线程id等于mark word的threadId即可，这样就省去了大量有关锁申请的操作。

不适用于锁竞争比较激烈的多线程场合

###### 3.4.1.2 轻量级锁（偏向锁的并发?）

​	由偏向锁膨胀而来：偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争的时候，偏向锁就升级为轻量级锁

适用于线程交替执行同步块

若存在同一时间访问同一锁的情况，则膨胀为重量级锁

轻量级锁加锁和解锁的过程 https://www.cnblogs.com/paddix/p/5405678.html

